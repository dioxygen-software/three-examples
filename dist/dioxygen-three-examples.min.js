var DioxygenThreeExamples=function(e,t){"use strict";class r extends t.ShaderMaterial{constructor(e){(e=e||{}).uniforms=t.UniformsUtils.merge([t.ShaderLib.normal.uniforms,{linearize_depth:{value:e.linearize_depth??!0}}]),e.vertexShader="varying mat4 vProjectionMatrix;\n"+t.ShaderLib.normal.vertexShader.replace("#include <uv_vertex>","vProjectionMatrix = projectionMatrix;\n#include <uv_vertex>"),e.fragmentShader="varying mat4 vProjectionMatrix;\nuniform bool linearize_depth;\n"+t.ShaderLib.normal.fragmentShader.replace("gl_FragColor = vec4( packNormalToRGB( normal ), opacity );","float zN = 2.0*gl_FragCoord.z - 1.0;\nfloat p23 = vProjectionMatrix[3][2];\nfloat k = (vProjectionMatrix[2][2] - 1.0f)/(vProjectionMatrix[2][2] + 1.0f);\nfloat inK = vProjectionMatrix[2][2] / p23;\nfloat zFar =  p23/(1.0f + p23*inK);\nfloat zNear =  1.0f/(inK - 1.0/p23);\nfloat linearizedDepth =  2.0 * zNear * zFar / (zFar  + zNear - zN * (zFar - zNear));\nfloat depth_e = linearize_depth ? linearizedDepth : zN;\ngl_FragColor = vec4( packNormalToRGB( normal ), depth_e );"),super(e),this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=t.TangentSpaceNormalMap,this.normalScale=new t.Vector2(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.isMeshNormalMaterial=!0,this.isMeshNormalDepthMaterial=!0}}class i extends t.MeshDepthMaterial{constructor(e){(e=e||{}).depthPacking=t.RGBADepthPacking,super(e)}}class o extends t.ShaderMaterial{constructor(e){(e=e||{}).uniforms=t.UniformsUtils.merge([t.ShaderLib.displacementmap]),e.vertexShader=["#include <common>","#include <displacementmap_pars_vertex>","#include <fog_pars_vertex>","#include <morphtarget_pars_vertex>","#include <skinning_pars_vertex>","#include <shadowmap_pars_vertex>","#include <logdepthbuf_pars_vertex>","#include <clipping_planes_pars_vertex>","varying vec3 vViewPosition;","void main() {","#include <skinbase_vertex>","#include <begin_vertex>","#include <morphtarget_vertex>","#include <skinning_vertex>","#include <displacementmap_vertex>","#include <project_vertex>","#include <logdepthbuf_vertex>","#include <clipping_planes_vertex>","vViewPosition = (viewMatrix * modelMatrix * vec4( transformed, 1.0)).xyz;","}"].join("\n"),e.fragmentShader=["varying vec3 vViewPosition;","void main() {","gl_FragColor = vec4(vViewPosition.xyz,1.0);","}"].join("\n"),super(e),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.skinning=!1,this.morphTargets=!1}}class n extends t.ShaderMaterial{constructor(e){(e=e||{}).uniforms=t.UniformsUtils.merge([t.ShaderLib.normal.uniforms,{viewMatrixInverse:{value:new t.Matrix4}}]),e.vertexShader=t.ShaderLib.normal.vertexShader,e.fragmentShader="uniform mat4 viewMatrixInverse;\n"+t.ShaderLib.normal.fragmentShader.replace("gl_FragColor = ","normal = normalize(mat3(viewMatrixInverse) * normal);\ngl_FragColor = "),super(e),this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=t.TangentSpaceNormalMap,this.normalScale=new t.Vector2(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.isMeshNormalMaterial=!0,this.isMeshWorldNormalMaterial=!0}updateMeshOnBeforeRender=function(e){const t=e.onBeforeRender;e.onBeforeRender=function(e,r,i,o,n,s){t.call(this,e,r,i,o,n,s),this.material.isMeshWorldNormalMaterial&&this.material.uniforms.viewMatrixInverse.value.copy(i.matrixWorld)}}}class s extends t.ShaderMaterial{constructor(e){(e=e||{}).uniforms=t.UniformsUtils.merge([t.ShaderLib.depth.uniforms]),e.vertexShader=["#include <common>","#include <displacementmap_pars_vertex>","#include <fog_pars_vertex>","#include <morphtarget_pars_vertex>","#include <skinning_pars_vertex>","#include <shadowmap_pars_vertex>","#include <logdepthbuf_pars_vertex>","#include <clipping_planes_pars_vertex>","varying vec4 vWorldPosition;","void main() {","#include <skinbase_vertex>","#include <begin_vertex>","#include <morphtarget_vertex>","#include <skinning_vertex>","#include <displacementmap_vertex>","#include <project_vertex>","#include <logdepthbuf_vertex>","#include <clipping_planes_vertex>","vWorldPosition = modelMatrix * vec4( transformed, 1.0 );","}"].join("\n"),e.fragmentShader=["varying vec4 vWorldPosition;","void main() {","gl_FragColor = vWorldPosition;","}"].join("\n"),super(e),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.skinning=!1,this.morphTargets=!1,this.isMeshDepthMaterial=!0,this.isMeshWorldPositionMaterial=!0}}class a{static computeTangents(e){e.computeTangents(),console.warn("THREE.BufferGeometryUtils: .computeTangents() has been removed. Use BufferGeometry.computeTangents() instead.")}static mergeBufferGeometries(e,r=!1){const i=null!==e[0].index,o=new Set(Object.keys(e[0].attributes)),n=new Set(Object.keys(e[0].morphAttributes)),s={},a={},l=e[0].morphTargetsRelative,u=new t.BufferGeometry;let f=0;for(let t=0;t<e.length;++t){const c=e[t];let m=0;if(i!==(null!==c.index))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+t+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(const e in c.attributes){if(!o.has(e))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+t+'. All geometries must have compatible attributes; make sure "'+e+'" attribute exists among all geometries, or in none of them.'),null;void 0===s[e]&&(s[e]=[]),s[e].push(c.attributes[e]),m++}if(m!==o.size)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+t+". Make sure all geometries have the same number of attributes."),null;if(l!==c.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+t+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(const e in c.morphAttributes){if(!n.has(e))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+t+".  .morphAttributes must be consistent throughout all geometries."),null;void 0===a[e]&&(a[e]=[]),a[e].push(c.morphAttributes[e])}if(u.userData.mergedUserData=u.userData.mergedUserData||[],u.userData.mergedUserData.push(c.userData),r){let e;if(i)e=c.index.count;else{if(void 0===c.attributes.position)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+t+". The geometry must have either an index or a position attribute"),null;e=c.attributes.position.count}u.addGroup(f,e,t),f+=e}}if(i){let t=0;const r=[];for(let i=0;i<e.length;++i){const o=e[i].index;for(let e=0;e<o.count;++e)r.push(o.getX(e)+t);t+=e[i].attributes.position.count}u.setIndex(r)}for(const e in s){const t=this.mergeBufferAttributes(s[e]);if(!t)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+e+" attribute."),null;u.setAttribute(e,t)}for(const e in a){const t=a[e][0].length;if(0===t)break;u.morphAttributes=u.morphAttributes||{},u.morphAttributes[e]=[];for(let r=0;r<t;++r){const t=[];for(let i=0;i<a[e].length;++i)t.push(a[e][i][r]);const i=this.mergeBufferAttributes(t);if(!i)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+e+" morphAttribute."),null;u.morphAttributes[e].push(i)}}return u}static mergeBufferAttributes(e){let r,i,o,n=0;for(let t=0;t<e.length;++t){const s=e[t];if(s.isInterleavedBufferAttribute)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported."),null;if(void 0===r&&(r=s.array.constructor),r!==s.array.constructor)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null;if(void 0===i&&(i=s.itemSize),i!==s.itemSize)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null;if(void 0===o&&(o=s.normalized),o!==s.normalized)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null;n+=s.array.length}const s=new r(n);let a=0;for(let t=0;t<e.length;++t)s.set(e[t].array,a),a+=e[t].array.length;return new t.BufferAttribute(s,i,o)}static interleaveAttributes(e){let r,i=0,o=0;for(let t=0,n=e.length;t<n;++t){const n=e[t];if(void 0===r&&(r=n.array.constructor),r!==n.array.constructor)return console.error("AttributeBuffers of different types cannot be interleaved"),null;i+=n.array.length,o+=n.itemSize}const n=new t.InterleavedBuffer(new r(i),o);let s=0;const a=[],l=["getX","getY","getZ","getW"],u=["setX","setY","setZ","setW"];for(let r=0,i=e.length;r<i;r++){const i=e[r],o=i.itemSize,f=i.count,c=new t.InterleavedBufferAttribute(n,o,s,i.normalized);a.push(c),s+=o;for(let e=0;e<f;e++)for(let t=0;t<o;t++)c[u[t]](e,i[l[t]](e))}return a}static estimateBytesUsed(e){let t=0;for(const r in e.attributes){const i=e.getAttribute(r);t+=i.count*i.itemSize*i.array.BYTES_PER_ELEMENT}const r=e.getIndex();return t+=r?r.count*r.itemSize*r.array.BYTES_PER_ELEMENT:0,t}static mergeVertices(e,r=1e-4){r=Math.max(r,Number.EPSILON);const i={},o=e.getIndex(),n=e.getAttribute("position"),s=o?o.count:n.count;let a=0;const l=Object.keys(e.attributes),u={},f={},c=[],m=["getX","getY","getZ","getW"];for(let t=0,r=l.length;t<r;t++){const r=l[t];u[r]=[];const i=e.morphAttributes[r];i&&(f[r]=new Array(i.length).fill().map((()=>[])))}const h=Math.log10(1/r),d=Math.pow(10,h);for(let t=0;t<s;t++){const r=o?o.getX(t):t;let n="";for(let t=0,i=l.length;t<i;t++){const i=l[t],o=e.getAttribute(i),s=o.itemSize;for(let e=0;e<s;e++)n+=~~(o[m[e]](r)*d)+","}if(n in i)c.push(i[n]);else{for(let t=0,i=l.length;t<i;t++){const i=l[t],o=e.getAttribute(i),n=e.morphAttributes[i],s=o.itemSize,a=u[i],c=f[i];for(let e=0;e<s;e++){const t=m[e];if(a.push(o[t](r)),n)for(let e=0,i=n.length;e<i;e++)c[e].push(n[e][t](r))}}i[n]=a,c.push(a),a++}}const g=e.clone();for(let r=0,i=l.length;r<i;r++){const i=l[r],o=e.getAttribute(i),n=new o.array.constructor(u[i]),s=new t.BufferAttribute(n,o.itemSize,o.normalized);if(g.setAttribute(i,s),i in f)for(let r=0;r<f[i].length;r++){const o=e.morphAttributes[i][r],n=new o.array.constructor(f[i][r]),s=new t.BufferAttribute(n,o.itemSize,o.normalized);g.morphAttributes[i][r]=s}}return g.setIndex(c),g}static toTrianglesDrawMode(e,r){if(r===t.TrianglesDrawMode)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),e;if(r===t.TriangleFanDrawMode||r===t.TriangleStripDrawMode){let i=e.getIndex();if(null===i){const t=[],r=e.getAttribute("position");if(void 0===r)return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),e;for(let e=0;e<r.count;e++)t.push(e);e.setIndex(t),i=e.getIndex()}const o=i.count-2,n=[];if(r===t.TriangleFanDrawMode)for(let e=1;e<=o;e++)n.push(i.getX(0)),n.push(i.getX(e)),n.push(i.getX(e+1));else for(let e=0;e<o;e++)e%2==0?(n.push(i.getX(e)),n.push(i.getX(e+1)),n.push(i.getX(e+2))):(n.push(i.getX(e+2)),n.push(i.getX(e+1)),n.push(i.getX(e)));n.length/3!==o&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const s=e.clone();return s.setIndex(n),s.clearGroups(),s}return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",r),e}static computeMorphedAttributes(e){if(!0!==e.geometry.isBufferGeometry)return console.error("THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry."),null;const r=new t.Vector3,i=new t.Vector3,o=new t.Vector3,n=new t.Vector3,s=new t.Vector3,a=new t.Vector3,l=new t.Vector3,u=new t.Vector3,f=new t.Vector3;function c(e,t,c,m,h,d,g,p,b){r.fromBufferAttribute(c,d),i.fromBufferAttribute(c,g),o.fromBufferAttribute(c,p);const v=e.morphTargetInfluences;if(t.morphTargets&&m&&v){l.set(0,0,0),u.set(0,0,0),f.set(0,0,0);for(let e=0,t=m.length;e<t;e++){const t=v[e],c=m[e];0!==t&&(n.fromBufferAttribute(c,d),s.fromBufferAttribute(c,g),a.fromBufferAttribute(c,p),h?(l.addScaledVector(n,t),u.addScaledVector(s,t),f.addScaledVector(a,t)):(l.addScaledVector(n.sub(r),t),u.addScaledVector(s.sub(i),t),f.addScaledVector(a.sub(o),t)))}r.add(l),i.add(u),o.add(f)}e.isSkinnedMesh&&(e.boneTransform(d,r),e.boneTransform(g,i),e.boneTransform(p,o)),b[3*d+0]=r.x,b[3*d+1]=r.y,b[3*d+2]=r.z,b[3*g+0]=i.x,b[3*g+1]=i.y,b[3*g+2]=i.z,b[3*p+0]=o.x,b[3*p+1]=o.y,b[3*p+2]=o.z}const m=e.geometry,h=e.material;let d,g,p;const b=m.index,v=m.attributes.position,x=m.morphAttributes.position,y=m.morphTargetsRelative,M=m.attributes.normal,w=m.morphAttributes.position,B=m.groups,A=m.drawRange;let S,_,T,E,z,G,U,R;const V=new Float32Array(v.count*v.itemSize),k=new Float32Array(M.count*M.itemSize);if(null!==b)if(Array.isArray(h))for(S=0,T=B.length;S<T;S++)for(z=B[S],G=h[z.materialIndex],U=Math.max(z.start,A.start),R=Math.min(z.start+z.count,A.start+A.count),_=U,E=R;_<E;_+=3)d=b.getX(_),g=b.getX(_+1),p=b.getX(_+2),c(e,G,v,x,y,d,g,p,V),c(e,G,M,w,y,d,g,p,k);else for(U=Math.max(0,A.start),R=Math.min(b.count,A.start+A.count),S=U,T=R;S<T;S+=3)d=b.getX(S),g=b.getX(S+1),p=b.getX(S+2),c(e,h,v,x,y,d,g,p,V),c(e,h,M,w,y,d,g,p,k);else if(void 0!==v)if(Array.isArray(h))for(S=0,T=B.length;S<T;S++)for(z=B[S],G=h[z.materialIndex],U=Math.max(z.start,A.start),R=Math.min(z.start+z.count,A.start+A.count),_=U,E=R;_<E;_+=3)d=_,g=_+1,p=_+2,c(e,G,v,x,y,d,g,p,V),c(e,G,M,w,y,d,g,p,k);else for(U=Math.max(0,A.start),R=Math.min(v.count,A.start+A.count),S=U,T=R;S<T;S+=3)d=S,g=S+1,p=S+2,c(e,h,v,x,y,d,g,p,V),c(e,h,M,w,y,d,g,p,k);return{positionAttribute:v,normalAttribute:M,morphedPositionAttribute:new t.Float32BufferAttribute(V,3),morphedNormalAttribute:new t.Float32BufferAttribute(k,3)}}}const l=new t.Vector3,u=new t.Vector3,f=new t.Vector3;return e.EdgeSplitModifier=class{modify(e,r,i=!0){function o(e,t,r){l.set(d[3*r],d[3*r+1],d[3*r+2]).normalize();const i={splitGroup:[],currentGroup:[r]};for(const o of e)o!==r&&(u.set(d[3*o],d[3*o+1],d[3*o+2]).normalize(),u.dot(l)<t?i.splitGroup.push(o):i.currentGroup.push(o));return i}function n(e,t,r=null){if(0===e.length)return;const i=[];for(const r of e)i.push(o(e,t,r));let s=i[0];for(const e of i)e.currentGroup.length>s.currentGroup.length&&(s=e);null!=r&&p.push({original:r,indexes:s.currentGroup}),s.splitGroup.length&&n(s.splitGroup,t,r||s.currentGroup[0])}if(!0===e.isGeometry)return void console.error("THREE.EdgeSplitModifier no longer supports THREE.Geometry. Use BufferGeometry instead.");let s=!1,c=null;if(e.attributes.normal&&(s=!0,e=e.clone(),!0===i&&null!==e.index&&(c=e.attributes.normal.array),e.deleteAttribute("normal")),null==e.index){if(void 0===a)throw"THREE.EdgeSplitModifier relies on BufferGeometryUtils";e=a.mergeVertices(e)}const m=e.index.array,h=e.getAttribute("position").array;let d,g;!function(){d=new Float32Array(3*m.length);for(let e=0;e<m.length;e+=3){let t=m[e];l.set(h[3*t],h[3*t+1],h[3*t+2]),t=m[e+1],u.set(h[3*t],h[3*t+1],h[3*t+2]),t=m[e+2],f.set(h[3*t],h[3*t+1],h[3*t+2]),f.sub(u),l.sub(u);const r=f.cross(l).normalize();for(let t=0;t<3;t++)d[3*(e+t)]=r.x,d[3*(e+t)+1]=r.y,d[3*(e+t)+2]=r.z}}(),function(){g=Array(h.length/3);for(let e=0;e<m.length;e++){const t=m[e];null==g[t]&&(g[t]=[]),g[t].push(e)}}();const p=[];for(const e of g)n(e,Math.cos(r)-.001);const b=h.length/e.getAttribute("position").itemSize,v=b+p.length,x={};for(const r of Object.keys(e.attributes)){const i=e.attributes[r],o=new i.array.constructor(v*i.itemSize);o.set(i.array),x[r]=new t.BufferAttribute(o,i.itemSize,i.normalized)}const y=new Uint32Array(m.length);y.set(m);for(let e=0;e<p.length;e++){const t=p[e],r=m[t.original];for(const t of Object.values(x))for(let i=0;i<t.itemSize;i++)t.array[(b+e)*t.itemSize+i]=t.array[r*t.itemSize+i];for(const r of t.indexes)y[r]=b+e}(e=new t.BufferGeometry).setIndex(new t.BufferAttribute(y,1));for(const t of Object.keys(x))e.setAttribute(t,x[t]);if(s&&(e.computeVertexNormals(),null!==c)){const t=new Array(c.length/3).fill(!1);for(const e of p)t[e.original]=!0;for(let r=0;r<t.length;r++)if(!1===t[r])for(let t=0;t<3;t++)e.attributes.normal.array[3*r+t]=c[3*r+t]}return e}},e.MeshNormalDepthMaterial=r,e.MeshRGBADepthMaterial=i,e.MeshViewPositionMaterial=o,e.MeshWorldNormalMaterial=n,e.MeshWorldPositionMaterial=s,e}({},THREE);
